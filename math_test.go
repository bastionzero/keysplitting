package keysplitting

import (
	"math/big"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("Keysplitting congruence", func() {
	Context("Small numbers", func() {
		two := big.NewInt(2)
		seven := big.NewInt(7)
		twentyTwo := big.NewInt(22)
		twentyThree := big.NewInt(23)

		It("Correctly gives a ≡ b (mod N)", func() {
			Expect(congruentModN(two, twentyThree, seven)).To(BeTrue(), "Incorrect result: 2 ≡ 23 (mod 7)")
		})

		It("Correctly gives a ≢ b (mod N)", func() {
			Expect(congruentModN(two, twentyTwo, seven)).To(BeFalse(), "Incorrect result: 2 ≢ 22 (mod 7)")
		})
	})

	Context("Big numbers", func() {
		a, _ := new(big.Int).SetString("14411463122699977911481627357183340675117845456707438151886283579067899255171385549601519500391210995137972501924606343388195146474013619734159781079685498658201113144791690767478757196033013131697249113257067485435669073579036912426360350296470577449136532036910043291259246967323053207699907512178076148392141516288449182280046005560019039285797538816539810991540734970862716352072470758097140109608253945643956391243277308531523000532104636037357061962162054649620332193535544425066365095465035661514291480613239481958015265678892802700102989291481101475511171557215245867772598787646290023362827514518150306784218", 10)
		b, _ := new(big.Int).SetString("38965315584263904078973081648317764640493971115037553027090460220716174050415051013509658443783208766093539266386911342603241926447260284126400057511764495518131474629756444578522734960852925074076136032794046480389824722126931013524061359165703966000698756230700978191368396484163176448482379161287132435685539646290095403497880669301541107166234140321665054890934047692044665168414204240267422982566354622416999917416786945418711252073690152845888175677537186955052766364225933570130171576980799602419418881968111582993814114315590873151930039158413696186420845693521291939382424105955906967995908355984955622271034", 10)
		n, _ := new(big.Int).SetString("24553852461563926167491454291134423965376125658330114875204176641648274795243665463908138943391997770955566764462304999215046779973246664392240276432078996859930361484964753811043977764819911942378886919536978994954155648547894101097701008869233388551562224193790934900109149516840123240782471649109056287293398130001646221217834663741522067880436601505125243899393312721181948816341733482170282872958100676773043526173509636887188251541585516808531113715375132305432434170690389145063806481515763940905127401354872101035798848636698070451827049866932594710909674136306046071609825318309616944633080841466805315486816", 10)

		It("Correctly gives a ≡ b (mod N)", func() {
			Expect(congruentModN(a, b, n)).To(BeTrue(), "Incorrect result: 2 ≡ 23 (mod 7)")
		})

		It("Correctly gives a ≢ b (mod N)", func() {
			Expect(congruentModN(a, b.Add(b, big.NewInt(1)), n)).To(BeFalse(), "Incorrect result: 2 ≢ 22 (mod 7)")
		})
	})
})

var _ = Describe("Keysplitting Euler totient", func() {
	Context("Small numbers", func() {
		It("Correctly gives phi(77837) == 77280", func() {
			// let p = 277 and q = 281. Then n = 77837
			phi := eulerTotient([]*big.Int{big.NewInt(277), big.NewInt(281)})
			Expect(phi.Cmp(big.NewInt(77280))).To(Equal(0), "Incorrect result: 2 ≡ 23 (mod 7)")
		})

		It("Correctly gives phi(9191070797) == 9125222400", func() {
			// let our primes equal 277, 281, and 118081. Then n = 9191070797
			phi := eulerTotient([]*big.Int{big.NewInt(277), big.NewInt(281), big.NewInt(118081)})
			Expect(phi.Cmp(big.NewInt(9125222400))).To(Equal(0), "Incorrect result: 2 ≡ 23 (mod 7)")
		})
	})
})
